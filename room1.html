<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Roomify – 2D Room Planner</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<style>
/* ========== GLOBAL ========== */
* { box-sizing: border-box; margin: 0; padding: 0; font-family: Segoe UI, system-ui; }
body { height: 100vh; display: flex; flex-direction: column; background: #eef6fb; }

/* ========== HEADER ========== */
header {
  height: 56px;
  background: #ffffff;
  box-shadow: 0 2px 6px rgba(0,0,0,.15);
  display: flex;
  align-items: center;
  padding: 0 20px;
}
header h1 { font-size: 20px; }

/* ========== APP LAYOUT ========== */
#app {
  flex: 1;
  display: flex;
  overflow: hidden;
}

/* ========== LEFT PANEL ========== */
#left-panel {
  width: 220px;
  background: #ccefff;
  padding: 12px;
}
#left-panel h3 { margin-bottom: 10px; font-size: 14px; }
.f-item {
  background: #8dd2ff;
  padding: 8px;
  border-radius: 8px;
  margin-bottom: 6px;
  cursor: grab;
  user-select: none;
}

/* ========== MAIN AREA ========== */
#main {
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
}

/* ========== CANVAS ========== */
#canvas {
  width: 85%;
  height: 85%;
  background:
    linear-gradient(to right, rgba(0,0,0,.08) 1px, transparent 1px),
    linear-gradient(to bottom, rgba(0,0,0,.08) 1px, transparent 1px);
  background-size: 20px 20px;
  border-radius: 16px;
  position: relative;
  overflow: hidden;
}

/* ========== SVG ROOM ========== */
#svg {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: 2;
  pointer-events: all;
}
.wall { stroke: #555; stroke-width: 4; cursor: pointer; }
.point { fill: #fff; stroke: #333; stroke-width: 2; cursor: grab; }
.wall-label { fill: #000; font-size: 12px; pointer-events: none; }

/* ========== FURNITURE ========== */
#furniture-layer {
  position: absolute;
  inset: 0;
  z-index: 3;
  pointer-events: none;
}
.furniture {
  position: absolute;
  background: #ffd27d;
  border: 2px solid #f59600;
  border-radius: 8px;
  padding: 4px 6px;
  font-size: 11px;
  cursor: move;
  pointer-events: auto;
}
.furniture.selected { border-color: #0070ff; }

.f-controls {
  position: absolute;
  top: -18px;
  right: -18px;
  opacity: 0;
}
.furniture:hover .f-controls { opacity: 1; }

.f-controls button {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: none;
  background: #0070ff;
  color: #fff;
  cursor: pointer;
}

/* ========== RESIZE PANEL ========== */
#resize-panel {
  position: absolute;
  bottom: 20px;
  right: 20px;
  background: #fff;
  padding: 10px;
  border-radius: 10px;
  box-shadow: 0 2px 8px rgba(0,0,0,.2);
  display: none;
  z-index: 10;
}
#resize-panel input { width: 70px; margin-top: 4px; }
</style>
</head>

<body>

<header>
  <h1>Roomify</h1>
</header>

<div id="app">

  <aside id="left-panel">
    <button id="draw-wall-btn" style="margin-bottom: 10px;">Draw Wall</button>
    <h3>Furniture</h3>
    <div class="f-item" draggable="true" data-name="Chair" data-w="40" data-h="40">Chair</div>
    <div class="f-item" draggable="true" data-name="Table" data-w="60" data-h="60">Table</div>
    <div class="f-item" draggable="true" data-name="Bed" data-w="120" data-h="60">Bed</div>
  </aside>

  <main id="main">
    <div id="canvas">
      <svg id="svg"></svg>
      <div id="furniture-layer"></div>

     <div id="resize-panel">
  <strong>Furniture Size (px)</strong><br>
  Width (px): <input id="rw" type="number" step="1"><br>
  Height (px): <input id="rh" type="number" step="1">
</div>

    </div>
  </main>

</div>
<div id="size-info"></div>

<script>
/* ================= CONFIG ================= */
const PIXELS_PER_FOOT = 20;
let wallDrawMode = false;
let wallStartPoint = null;

/* ================= WALL DRAWING Mode ================= */
document.getElementById("draw-wall-btn").onclick = () => {
  wallDrawMode = true;
  wallStartPoint = null;
  canvas.style.cursor = "crosshair";
};

/* ================= ROOM ================= */
const svg = document.getElementById("svg");
const canvas = document.getElementById("canvas");

let vertices = [];
let draggingPoint = null;

function initRoom() {
  const r = canvas.getBoundingClientRect();
  if (r.width === 0 || r.height === 0) return;

  const w = Math.min(400, r.width * 0.6);
  const h = Math.min(300, r.height * 0.6);
  const cx = r.width / 2;
  const cy = r.height / 2;

  vertices = [
    {x: cx-w/2, y: cy-h/2},
    {x: cx+w/2, y: cy-h/2},
    {x: cx+w/2, y: cy+h/2},
    {x: cx-w/2, y: cy+h/2}
  ];
  drawRoom();
}

function drawRoom() {
  svg.innerHTML = "";

  for (let i = 0; i < vertices.length; i++) {
    const a = vertices[i];
    const b = vertices[(i+1) % vertices.length];

    const line = document.createElementNS("http://www.w3.org/2000/svg","line");
    line.setAttribute("x1", a.x);
    line.setAttribute("y1", a.y);
    line.setAttribute("x2", b.x);
    line.setAttribute("y2", b.y);
    line.setAttribute("class", "wall");

    line.ondblclick = () => {
      vertices.splice(i+1, 0, { x:(a.x+b.x)/2, y:(a.y+b.y)/2 });
      drawRoom();
    };

    line.onclick = (e) => {
      if (!wallDrawMode) return;

      const r = svg.getBoundingClientRect();
      const x = e.clientX - r.left;
      const y = e.clientY - r.top;

      vertices.splice(i+1, 0, { x, y });

      wallDrawMode = false;
      svg.style.cursor = "default";
      drawRoom();
    }
    svg.appendChild(line);

    const len = Math.hypot(b.x-a.x, b.y-a.y) / PIXELS_PER_FOOT;
    const t = document.createElementNS("http://www.w3.org/2000/svg","text");
    t.setAttribute("x",(a.x+b.x)/2);
    t.setAttribute("y",(a.y+b.y)/2 - 6);
    t.setAttribute("class","wall-label");
    t.textContent = len.toFixed(1) + " ft";
    svg.appendChild(t);
  }

  vertices.forEach((p,i)=>{
    const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
    c.setAttribute("cx", p.x);
    c.setAttribute("cy", p.y);
    c.setAttribute("r", 6);
    c.setAttribute("class", "point");
    c.onmousedown = () => draggingPoint = i;
    c.oncontextmenu = e => {
      e.preventDefault();
      if (vertices.length > 3) {
        vertices.splice(i,1);
        drawRoom();
      }
    };
    svg.appendChild(c);
  });
}

document.addEventListener("mousemove", e => {
  if (draggingPoint === null) return;
  const r = canvas.getBoundingClientRect();
  vertices[draggingPoint].x = e.clientX - r.left;
  vertices[draggingPoint].y = e.clientY - r.top;
  drawRoom();
});
document.addEventListener("mouseup", () => draggingPoint = null);

/* ================= FURNITURE ================= */
const furnitureLayer = document.getElementById("furniture-layer");
const resizePanel = document.getElementById("resize-panel");
const rw = document.getElementById("rw");
const rh = document.getElementById("rh");

let furniture = {}, nextId = 1;
let draggingFurniture = null, offset = {}, selected = null;

function pointInPolygon(p, poly) {
  let inside = false;
  for (let i=0,j=poly.length-1;i<poly.length;j=i++) {
    const xi=poly[i].x, yi=poly[i].y;
    const xj=poly[j].x, yj=poly[j].y;
    const intersect = ((yi>p.y)!=(yj>p.y)) &&
      (p.x < (xj-xi)*(p.y-yi)/(yj-yi)+xi);
    if (intersect) inside = !inside;
  }
  return inside;
}
function rectInsidePolygon(x, y, w, h, poly) {
  const corners = [
    { x: x,     y: y },
    { x: x + w, y: y },
    { x: x + w, y: y + h },
    { x: x,     y: y + h }
  ];
  return corners.every(pt => pointInPolygon(pt, poly));
}


function overlap(id,x,y,w,h){
  for(const k in furniture){
    if(k===id) continue;
    const o=furniture[k];
    const ox=parseFloat(o.el.style.left);
    const oy=parseFloat(o.el.style.top);
    if(x<ox+o.w && x+w>ox && y<oy+o.h && y+h>oy) return true;
  }
  return false;
}

function createFurniture(name,w,h,x,y){
  const id="f"+nextId++;
  const el=document.createElement("div");
  el.className="furniture";
  el.style.width=w+"px";
  el.style.height=h+"px";
  el.style.left=x-w/2+"px";
  el.style.top=y-h/2+"px";
  el.innerHTML=`<b>${name}</b>`;

  const ctr=document.createElement("div");
  ctr.className="f-controls";
  const del=document.createElement("button");
  del.textContent="✕";
  ctr.appendChild(del);
  el.appendChild(ctr);

  del.onclick=e=>{
    e.stopPropagation();
    el.remove();
    delete furniture[id];
    resizePanel.style.display="none";
  };

  el.onmousedown=e=>{
    e.stopPropagation();
    draggingFurniture=id;
    selected=id;

    document.querySelectorAll(".furniture").forEach(f=>f.classList.remove("selected"));
    el.classList.add("selected");

    rw.value=furniture[id].w;
    rh.value=furniture[id].h;
    resizePanel.style.display="block";

    const r=el.getBoundingClientRect();
    offset.x=e.clientX-r.left;
    offset.y=e.clientY-r.top;
  };

  furnitureLayer.appendChild(el);
  furniture[id]={el,w,h};
}

document.addEventListener("mousemove",e=>{
  if(!draggingFurniture) return;
  const it=furniture[draggingFurniture];
  const r=canvas.getBoundingClientRect();
  const nx=e.clientX-r.left-offset.x;
  const ny=e.clientY-r.top-offset.y;
  const c={x:nx+it.w/2,y:ny+it.h/2};

 if(
  rectInsidePolygon(nx, ny, it.w, it.h, vertices) &&
  !overlap(draggingFurniture, nx, ny, it.w, it.h)
){

    it.el.style.left=nx+"px";
    it.el.style.top=ny+"px";
  }
});
document.addEventListener("mouseup",()=>draggingFurniture=null);

rw.onchange=rh.onchange=()=>{
  if(!selected) return;
  const it=furniture[selected];
  const w = Math.round(Number(rw.value));
const h = Math.round(Number(rh.value));
  const x=parseFloat(it.el.style.left), y=parseFloat(it.el.style.top);
  const c={x:x+w/2,y:y+h/2};

  if(
  rectInsidePolygon(x, y, w, h, vertices) &&
  !overlap(selected, x, y, w, h)
){

    it.w=w; it.h=h;
    it.el.style.width=w+"px";
    it.el.style.height=h+"px";
  } else {
    rw.value=it.w;
    rh.value=it.h;
  }
};

document.querySelectorAll(".f-item").forEach(i=>{
  i.ondragstart=()=>window.dragData={n:i.dataset.name,w:+i.dataset.w,h:+i.dataset.h};
});
canvas.ondragover=e=>e.preventDefault();
canvas.ondrop=e=>{
  const r=canvas.getBoundingClientRect();
  createFurniture(dragData.n,dragData.w,dragData.h,e.clientX-r.left,e.clientY-r.top);
};

window.addEventListener("load", initRoom);
window.addEventListener("resize", initRoom);
const sizeInfo = document.getElementById("size-info");

function updateSizeInfo(w, h) {
  const wf = (w / PIXELS_PER_FOOT).toFixed(2);
  const hf = (h / PIXELS_PER_FOOT).toFixed(2);
  sizeInfo.textContent = `${wf} ft × ${hf} ft`;
}
updateSizeInfo(it.w, it.h);

</script>

</body>
</html>